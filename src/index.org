#+TITLE: cleopatra
#+AUTHOR: Thomas Letan

We introduce *~cleopatra~*, a generic, extensible toolchain for literate
programming project using [[https://orgmode.org/][Org mode]].  The key concept
of *~cleopatra~* is to write so-called generation processes as Makefile rules.

* A Rust Project

#+BEGIN_SRC toml :tangle Cargo.toml :noweb yes :exports none
[package]
name = "cleopatra"
version = "1.0.0-dev"
edition = "2018"

<<gen-cargo-deps(deps=dependencies-info)>>
#+END_SRC

** Dependencies

#+NAME: dependencies-info
| ~clap~  | ~"2.33"~                                   | Parsing the command-line arguments                |
| ~serde~ | ~{ version = "*", features = ["derive"] }~ | Serialization and deserialization for Rust values |
| ~toml~  | ~"*"~                                      | Parsing the configuration file                    |

* ~cleopatra~ Library

#+BEGIN_SRC rust :tangle src/lib.rs :exports none
pub mod error;
pub mod configuration;
#+END_SRC

** Error Handling

#+BEGIN_SRC rust :tangle src/error.rs :exports none
pub struct Error(pub String);

impl Error {
    pub fn new(str : &str) -> Error {
        Error(String::from(str))
    }
}

pub trait Raise {
    type Out;

    fn or_raise(self, msg : &str) -> Self::Out;
}

impl<T> Raise for Option<T> {
    type Out = Result<T, Error>;

    fn or_raise(self, msg : &str) -> Result<T, Error> {
        self.ok_or(Error(String::from(msg)))
    }
}

impl<T, E> Raise for Result<T, E> {
    type Out = Result<T, Error>;

    fn or_raise(self, msg : &str) -> Result<T, Error> {
        self.map_err(|_| Error(String::from(msg)))
    }
}
#+END_SRC

** Configuration

#+BEGIN_SRC rust :tangle src/configuration.rs :noweb yes :exports none
use std::path::{Path, PathBuf};
use serde::{Serialize, Deserialize};
use crate::error::{Error, Raise};

<<gen-rust-struct(pub='t, name="Config", fields=conf-fields, derive=conf-derive)>>

impl Config {
  <<config-impl>>
}
#+END_SRC

A *~cleopatra~* project is configured with a configuration file called
~cleopatra.toml~.

*** The ~cleopatra.toml~ File

The ~cleopatra.toml~ file serves two purpose: it identifies the root of your
project, and it contains configuration data that can be used by *~cleopatra~*.

The content of this file is encoded in Rust using the =Config= structure, with
the following fields:

#+NAME: conf-fields
| ~pub generation_process~ | ~PathBuf~ | Path to the directory where the generation processes are defined |

And default implementations for the following traits:

#+NAME: conf-derive
- ~Serialize~
- ~Deserialize~

#+BEGIN_SRC rust :noweb-ref config-impl :exports none :noweb yes
<<read-from-file-proto>> {
  <<read-from-file-body>>
}
#+END_SRC

#+BEGIN_SRC rust :noweb-ref read-from-file-proto
pub fn read_from_file(file : &Path) -> Result<Config, Error>
#+END_SRC

#+BEGIN_SRC rust :noweb-ref read-from-file-body
let content : String = std::fs::read_to_string(file)
    .or_raise(&format!(
        "Could not read the content of the configuration file {:?}",
        file
    ))?;

toml::from_str(content.as_str())
    .or_raise(&format!("could not parse {:?}", file))
#+END_SRC

#+BEGIN_SRC rust :noweb-ref config-impl :exports none :noweb yes
<<find-project-proto>> {
  <<find-project-body>>
}
#+END_SRC

#+BEGIN_SRC rust :noweb-ref find-project-proto
pub fn with_project<A, T>(k : T) -> Result<A, Error>
where T : FnOnce(Config) -> Result<A, Error>
#+END_SRC

#+BEGIN_SRC rust :noweb-ref find-project-body
let origin : PathBuf = std::env::current_dir()
    .or_raise("Cannot get current directory")?;

let mut cwd : PathBuf = origin.clone();

loop {
    cwd.push("cleopatra.toml"); // (*)

    if cwd.exists() {
        let project = Config::read_from_file(&cwd)?;

        cwd.pop(); // we pop `cleopatra.toml` (see (*))
        std::env::set_current_dir(cwd)
            .or_raise("Could not move to the root of the project")?;

        let res = k(project);

        std::env::set_current_dir(origin)
            .or_raise("Could not return from the root of the project")?;

        return res;
    } else {
        // We `pop` a first time for `cleopatra.toml`, since we have pushed
        // previously it (see (*))
        cwd.pop();

        // We `pop` a second time to get the parent directory of cwd.  If
        // `pop` returns false, we are at the root of the current FS, and
        // there is no project file to find.
        if !cwd.pop() {
            return Err(Error::new("could not find cleopatra.toml"));
        }
    }
}
#+END_SRC


* Library of Babel

#+NAME: top-tail-fun
#+BEGIN_SRC emacs-lisp
(defun top-tail (str)
  (let ((len (length str)))
    (substring str 1 (- len 1))))
#+END_SRC

** Generating a Crate’s List of Dependencies

#+NAME: deps-test
| ~nom~  | ~"5"~ | Parsing something with style        |
| ~clap~ | ~"*"~ | Dealing with command-line arguments |

generates the following TOML entry.

#+BEGIN_SRC toml :noweb yes
<<gen-cargo-deps()>>
#+END_SRC

#+NAME: gen-cargo-deps
#+BEGIN_SRC emacs-lisp :var deps=deps-test :noweb yes
<<top-tail-fun>>

(format
 "[dependencies]\n%s"
 (mapconcat (lambda (dep)
              (format "%s = %s"
                      (top-tail (nth 0 dep))
                      (top-tail (nth 1 dep))))
            deps
            "\n"))
#+END_SRC

** Generating a Rust Structure

#+NAME: derive-auto
- ~Serialize~
- ~Deserialize~

#+NAME: struct-test
| ~field1~ | ~isize~   | Some integer because why not |
| ~field2~ | ~PathBuf~ | Let’s be parametric          |

generates the following Rust struct

#+BEGIN_SRC toml :noweb yes
<<gen-rust-struct(derive=derive-auto)>>
#+END_SRC

#+NAME: gen-rust-struct
#+BEGIN_SRC emacs-lisp :var pub='nil :var derive='nil :var fields=struct-test :var type-args="" :var name="Test" :noweb yes
<<top-tail-fun>>

(let* ((derive (format (mapconcat (lambda (x) (top-tail (car x))) derive ", ")))
       (derive-str (if derive (format "#[derive(%s)]\n" derive) "")))
  (format
   "%s%sstruct %s%s {\n%s\n}"
   derive-str
   (if pub "pub " "")
   name
   type-args
   (mapconcat (lambda (field)
                (format
                 "    /// %s\n    %s : %s,"
                 (nth 2 field)
                 (top-tail (nth 0 field))
                 (top-tail (nth 1 field))))
              fields
              "\n"))))

#+END_SRC
