#+TITLE: Cleopatry Binary
#+AUTHOR: Thomas Letan
#+HTML_LINK_UP: index.html

* Command-line Interface

#+BEGIN_SRC emacs-lisp :noweb-ref cli-specs :noweb yes
(version: "<<cleopatra-version()>>")
(author: "Thomas Letan <lthms@soap.coffee")
(about: "An extensible toolchain with facilities for literate programming")

(@subcommand exec =>
  (about: "Execute a command from the root of the current project")
  (@arg CMD: +required +takes_value +multiple "The command to run"))
#+END_SRC

* Commands

** ~cleopatra~

~cleopatra~ will executes the default command, that is building the current
project.

#+BEGIN_SRC rust :noweb-ref subcommands-func :exports none :noweb yes
<<build-proto>> {
    <<build-body>>
}
#+END_SRC

#+BEGIN_SRC rust :noweb-ref build-proto
fn build_subcommand() -> Result<(), Error>
#+END_SRC

#+BEGIN_SRC rust :noweb-ref build-body
Config::find_project_then(|project| {
    // TODO: CLEOPATRA_DIRECTORY is hardcoded here
    exec(&vec!["make", "-f", ".cleopatra/boot.mk", "init"])?;
    exec(&vec!["make", "-f", ".cleopatra/boot.mk", "postbuild"])
})
#+END_SRC

** ~cleopatra exec~

~cleopatra exec CMD~ will execute ~CMD~ from the root of the current cleopatra
project, with the environment variables defined in the cleopatra.toml set as
expected.

So, for instance

#+BEGIN_SRC shell
cleopatra exec printenv ROOT
#+END_SRC

will print the root of the project, that is the directory which contains
~cleopatra.toml~.

#+BEGIN_SRC rust :noweb-ref subcommands-func :exports none :noweb yes
<<exec-proto>> {
    <<exec-body>>
}
#+END_SRC

#+BEGIN_SRC rust :noweb-ref exec-proto
fn sh_subcommand(cmd : &[&str]) -> Result<(), Error>
#+END_SRC

#+BEGIN_SRC rust :noweb-ref exec-body
Config::find_project_then(|_| {
    exec(cmd)
})
#+END_SRC

* Helpers
** =exec=

#+BEGIN_SRC rust :noweb-ref helpers
fn exec(cmd : &[&str]) -> Result<(), Error> {
    Command::new(cmd[0])
        .args(cmd.split_at(1).1)
        .status()
        .or_raise("Could not execute submitted command")
        .and_then(|status| {
            if status.success() {
                Ok(())
            } else {
                Err(Error::new(&format!("The command {:?} failed", cmd)))
            }
        })
}
#+END_SRC

* The =main= of Cleopatra

#+BEGIN_SRC rust :tangle app/main.rs :noweb yes :exports none
#[macro_use] extern crate clap;

use cleopatra::configuration::Config;
use cleopatra::error::{Error, Raise};
use std::process::Command;

fn main() -> Result<(), Error> {
    let matches = clap_app!(myapp =>
        <<cli-specs>>
    ).get_matches();

    match matches.subcommand() {
        ("", _) => build_subcommand(),
        ("exec", Some(args)) =>
            sh_subcommand(
                &args.values_of("CMD")
                    .unwrap()
                    .collect::<Vec<&str>>()
            ),
        _ => unimplemented!(),
    }?;

    Ok(())
}

<<subcommands-func>>

<<helpers>>
#+END_SRC
