#+TITLE: Cleopatry Binary
#+AUTHOR: Thomas Letan
#+HTML_LINK_UP: index.html

#+BEGIN_SRC rust :tangle src/main.rs :noweb yes :exports none
#[macro_use] extern crate clap;

use std::process::Command;
use colored::*;
use clap::ArgMatches;

use crate::configuration::Config;
use crate::error::{Error, Raise};

pub mod error;
pub mod configuration;

<<main>>

<<run>>

<<args>>

<<subcommands-func>>

<<helpers>>
#+END_SRC

In this document, we explain the implementation of the ~cleopatra~ CLI tool. We
do not try to parse command-line arguments ourselves, but we rather rely on
[[https://clap.rs/][~clap~]], a powerful Rust crate that can do it for us as
long as we provide a specification for the desired CLI.  ~clap~ encodes a CLI
specification as a Rust structure called
[[https://docs.rs/clap/2.33.0/clap/struct.App.html][=App=]] which follows the
/builder/ pattern. This quickly becomes cumbersome and verbose to use, and this
is why over time ~clap~ has implemented more high-level way to define a CLI.

We proceed as follows: we use the =clap_app!= macro to build the =App= type
using a S-Expression. Rather than defining the S-Expression at one place, and
then provide an implementation for the related CLI, we enjoy the facilities
provided by literate programming and the ~noweb~ feature of Babel to provide the
specification of a given subcommand and its implementation in the same section.

* Commands

** ~cleopatra~

#+BEGIN_SRC emacs-lisp :noweb-ref cli-specs :noweb yes
(version: "<<cleopatra-version()>>")
(author: "Thomas Letan <lthms@soap.coffee")
(about: "An extensible toolchain with facilities for literate programming")
#+END_SRC

~cleopatra~ will executes the default command, that is building the current
project.

#+BEGIN_SRC rust :noweb-ref subcommands-func :noweb yes
fn build_subcommand() -> Result<(), Error> {
    Config::find_project_then(|_| {
        // TODO: CLEOPATRA_DIRECTORY is hardcoded here
        exec(&vec!["make", "-f", ".cleopatra/boot.mk", "init"])?;
        exec(&vec!["make", "-f", ".cleopatra/boot.mk", "postbuild"])
    })
}
#+END_SRC

** ~cleopatra exec~

~cleopatra exec CMD~ will execute ~CMD~ from the root of the current cleopatra
project, with the environment variables defined in the cleopatra.toml set as
expected.

#+BEGIN_SRC emacs-lisp :noweb-ref cli-specs :noweb yes
(@subcommand exec =>
  (about: "Execute a command from the root of the current project")
  (@setting TrailingVarArg)
  (@arg CMD: +required +takes_value +multiple "The command to run"))
#+END_SRC

So, for instance

#+BEGIN_SRC shell
cleopatra exec printenv ROOT
#+END_SRC

will print the root of the project, that is the directory which contains
~cleopatra.toml~.

#+BEGIN_SRC rust :noweb-ref subcommands-func :noweb yes
fn sh_subcommand(cmd : &[&str]) -> Result<(), Error> {
    Config::find_project_then(|_| {
       exec(cmd)
    })
}
#+END_SRC

* Helpers
** =exec=

#+BEGIN_SRC rust :noweb-ref helpers
fn exec(cmd : &[&str]) -> Result<(), Error> {
    Command::new(cmd[0])
        .args(cmd.split_at(1).1)
        .status()
        .or_raise("Could not execute submitted command")
        .and_then(|status| {
            if status.success() {
                Ok(())
            } else {
                Err(Error::Anomaly(format!("The command `{}' failed", cmd.join(" "))))
            }
        })
}
#+END_SRC

* =main=

#+BEGIN_SRC rust :noweb-ref args :noweb no-export :exports none
fn args() -> ArgMatches<'static> {
    clap_app!(myapp =>
            <<cli-specs>>
        ).get_matches()
}
#+END_SRC

#+BEGIN_SRC rust :noweb-ref main
fn main() -> () {
    match run(args()) {
        Err(err) => {
            let msg = err.message();
            eprintln!("{} {}\n{}", "Error:".red().bold(), msg.title, msg.description);
            std::process::exit(1);
        },
        _ => (),
    }
}
#+END_SRC

#+BEGIN_SRC rust :noweb-ref run :noweb yes
fn run(matches : ArgMatches) -> Result<(), Error> {
    match matches.subcommand() {
        ("", _) => build_subcommand(),
        ("exec", Some(args)) =>
            sh_subcommand(
                &args.values_of("CMD")
                    .unwrap()
                    .collect::<Vec<&str>>()
            ),
        _ => unimplemented!(),
    }?;

    Ok(())
}
#+END_SRC
