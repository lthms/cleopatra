#+TITLE: Cleopatra Projects
#+AUTHOR: Thomas Letan
#+HTML_LINK_UP: ../cleopatra-crate.html

* Configuration

#+BEGIN_SRC rust :tangle src/configuration.rs :noweb yes :exports none
use std::path::{Path, PathBuf};
use std::collections::HashMap;
use std::ffi::OsString;
use serde::{Serialize, Deserialize};
use crate::error::{Error, Raise};

<<gen-rust-struct(pub='t, name="Config", fields=conf-fields, derive=conf-derive)>>

impl Config {
  <<config-impl>>
}

<<helpers>>
#+END_SRC

A *~cleopatra~* project is configured with a configuration file called
~cleopatra.toml~.

** The ~cleopatra.toml~ File

The ~cleopatra.toml~ file serves two purpose: it identifies the root of your
project, and it contains configuration data that can be used by *~cleopatra~*.

The content of this file is encoded in Rust using the =Config= structure, with
the following fields:

#+NAME: conf-fields
| ~pub generation_processes~  | ~PathBuf~                   | Path to the directory where the generation processes are defined                  |
| ~#[serde(default)] pub env~ | ~HashMap<String, OsString>~ | Collection of environment variable to set before calling the generation processes |

And default implementations for the following traits:

#+NAME: conf-derive
- ~Serialize~
- ~Deserialize~
- ~Debug~

We proceed with the methods implemented for the type =Config=.

** =find_project_then=: Searching for a Project to Work With

#+BEGIN_SRC rust :noweb-ref config-impl :exports none :noweb yes
<<find-project-proto>> {
  <<find-project-body>>
}
#+END_SRC

=find_project_then= is a static method for =Config= which recursively looks for
a configuration file (~cleopatra.toml~) up until the root of the
filesystem. This function uses what we will call the ~with~ pattern: rather than
returning a result for its caller to use, =find_project_then= takes a
continuation as its argument, and call it once it has created an instance of
=Config=.

#+BEGIN_SRC rust :noweb-ref find-project-proto
pub fn find_project_then<A, K>(k : K) -> Result<A, Error>
where
    K : Copy + FnOnce(&Config) -> Result<A, Error>
#+END_SRC

#+BEGIN_NOTE
The fact that the continuation needs to implement =Copy= is due to the fact that
~k~ is moved several times.

Internally we use helpers functions to set-up the execution environment which
takes a closure as arguments. We chain these helpers, meaning the call to the
second helper is performed within the closure taken as argument by the first
one, and so one until we finally call the continuation ~k~.

From Rust perspective, it means ~k~ is moved \( n \) times.
#+END_NOTE

Using this approach allows us to setting-up a particular execution context. More
precisely, we use =find_file= to find a ~cleopatra.toml~ file.  Then, we parse
it as a TOML file, and chain helpers function which set-up the expected context,
and restore the previous one once the continuation ~k~ returns.

#+BEGIN_SRC rust :noweb-ref find-project-body
let path = find_file("cleopatra.toml")?;
let project = Config::read_from_file(&path)?;
with_cwd(&project.root(), || with_env(&project.env, || k(&project)))
#+END_SRC

Therefore, =find_project_then= relies on several helpers, whose types and
implementation are relatively straightforward.

=read_from_file= is defined as a method of the type =Config=. As a first step,
it calls the ~toml~ crate to parse the content of the file passed as
argument. Then, it postprocess the ~Config~ object by:

  - Adding the ~ROOT~ entry  in the ~env~ hash map

#+BEGIN_SRC rust :noweb-ref config-impl
fn read_from_file(file : &Path) -> Result<Self, Error> {
    let content : String = std::fs::read_to_string(file)
        .or_raise(&format!(
            "Could not read the content of the configuration file {:?}",
            file
        ))?;

    let mut project = toml::from_str::<Config>(content.as_str())
        .or_raise(&format!("could not parse {:?}", file))?;
    let parent = file.parent()
        .or_raise("Could not get the directory of configuration file")?;

    project.env.insert(String::from("ROOT"), OsString::from(parent));

    return Ok(project);
}
#+END_SRC

=find_file= is a regular function which recursively search for a file, from the
current directory up to the root of the filesystem.

#+BEGIN_SRC rust :noweb-ref helpers :noweb yes
fn find_file(filename : &str) -> Result<PathBuf, Error> {
    let mut cwd : PathBuf = std::env::current_dir()
        .or_raise("Cannot get current directory")?;

    loop {
        let candidate = cwd.join(filename);

        if candidate.exists() {
            return Ok(candidate);
        }

        if !cwd.pop() {
            return Err(Error::new("could not find cleopatra.toml"));
        }
    }
}
#+END_SRC

The other helpers aim to set-up the execution context of the =find_project_then=
continuation, and are defined as regular functions private to the
~configuration~ module.

#+BEGIN_SRC rust :noweb-ref helpers :noweb yes
fn with_cwd<K, A>(target : &Path, k : K) -> Result<A, Error>
where
    K : FnOnce() -> Result<A, Error> {
    let origin : PathBuf = std::env::current_dir()
        .or_raise("Cannot get current directory")?;

    std::env::set_current_dir(target)
        .or_raise(&format!("Could not move to the directory {:?}", target))?;

    let res = k();

    std::env::set_current_dir(origin)
        .or_raise(&format!("Could not return from the directory {:?}", target))?;

    return res;
}
#+END_SRC

#+BEGIN_SRC rust :noweb-ref helpers :noweb yes
fn with_env<K, A>(env : &HashMap<String, OsString>, k : K) -> Result<A, Error>
where
    K : FnOnce() -> Result<A, Error> {
    let context : HashMap<&String, Option<OsString>> = env
        .iter()
        .map(|(var, val)| {
            let old = std::env::var_os(var);
            std::env::set_var(var, val);
            (var, old)
        })
        .collect();

    let res = k();

    for (var, old) in context {
        match old {
            Some(val) => std::env::set_var(var, val),
            None => std::env::remove_var(var),
        }
    }

    return res;
}
#+END_SRC

** =root=: Retreive the root directory of a project

#+BEGIN_SRC rust :noweb-ref config-impl :noweb yes :exports none
<<root-proto>> {
    <<root-body>>
}
#+END_SRC

We provide a public method =root=, such that ~conf.root()~ returns the path of
the root directory of the considered project.

#+BEGIN_SRC rust :noweb-ref root-proto
pub fn root(&self) -> PathBuf
#+END_SRC

The implementation is currently *potentially unsafe* if the =Config= object has
not be constructed correctly. Indeed, we assume that the ~env~ hash map has a
value for the ~ROOT~ key, which is the case with =find_project_then=.

#+BEGIN_SRC rust :noweb-ref root-body
self.env["ROOT"].clone().into()
#+END_SRC
